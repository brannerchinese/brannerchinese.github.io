<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>&</title>
	<meta name="description" content="">
	<meta name="author" content="David Prager Branner">

	<!-- HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="http://brannerchinese.github.io/theme/html5.js"></script>
	<![endif]-->

	<!-- Styles -->
	<link href="http://brannerchinese.github.io/theme/bootstrap.min.css" rel="stylesheet">
	<link href="http://brannerchinese.github.io/theme/local.css" rel="stylesheet">
	<link href="http://brannerchinese.github.io/theme/pygments.css" rel="stylesheet">

    <!-- Feeds -->
    <link href="http://brannerchinese.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="& Atom Feed" />

</head>
<body>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="http://brannerchinese.github.io/">&</a>
			<ul class="nav">
					<li class="active"><a href="http://brannerchinese.github.io/category/misc.html">misc</a></li>
			</ul>
			<p class="pull-right"><a href="http://brannerchinese.github.io/archives.html">[archives]</a> <a href="http://brannerchinese.github.io/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">
	  <div class="sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
				<li><a href="https://brannerchinese.com/dpb/publications.html">Publications</a></li>
			</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
				<li><a href="/feeds/all.atom.xml">RSS</a></li>
			</ul>
			</div>
		</div>
	  </div>
	  <div class="content">
	<div class='article'>
		<div class="page-header"><h1>A question about time complexity when testing membership in a Python nested sequence</h1></div>
		<div class="well small">Permalink: <a class="more" href="http://brannerchinese.github.io/a-question-about-time-complexity-when-testing-membership-in-a-python-nested-sequence.html">2013-07-22 16:22:00</a>
by <a class="url fn" href="http://brannerchinese.github.io/author/david-prager-branner.html">David Prager Branner </a>
 in <a href="http://brannerchinese.github.io/category/misc.html">misc</a>
</div>
		<div><p><strong>(Corrected at bottom.)</strong></p>
<p>Python's <code>in</code> operator tests for membership in a sequence.</p>
<p>In [1]: a = [1, 2, 3]</p>
<p>In [2]: 1 in a</p>
<p>Out[2]: True</code></p>
<p>But it does not work directly on nested sequences such as a list of
lists or two-dimensional matrix:</p>
<p>In [3]: a = [[1, 2, 3], [4, 5, 6]]</p>
<p>In [4]: 1 in a</p>
<p>Out[4]: False</code></p>
<p>What is the most efficient way to do that?</p>
<hr />
<p>I thought of three approaches:</p>
<ol>
<li>Iteration through the first-level sequences composing the matrix,
    using a list comprehension</li>
<li>Flattening the matrix first</li>
<li>Creating the matrix in flat form to begin with</li>
</ol>
<p>My prediction was that creating the matrix in flat form to begin with
would be the fastest and that flattening the matrix first would be the
slowest. Of course, flattening a matrix is likely to increase the
running time.</p>
<p>I wrote five tests. For matrices with very small dimensions, my
predictions are correct. But as the dimensions become large, iterating
through the first-level sequences turned out to be significantly faster
than all other methods. <strong>[Wrong! There was an error in my code. I've
corrected it after the end of the original post.]</strong> Below I discuss only
the two most interesting ones.</p>
<p><strong>Results</strong></p>
<p>I populated the matrix with random floating point numbers and searched
for an additional random floating point number in it; that should give
worst-case performance since it is unlikely that any 16-digit random
numbers would appear twice in such relatively small samples.</p>
<p>The difference in speed for the plain use of the <code>in</code> operator looks
like it must involve a difference in time complexity, but I that there
is such a difference; I'd be happy to hear from anyone who can explain
this to me.</p>
<ol>
<li>
Creating the matrix in flat form to begin with

python -m timeit -s '\  

from random import random;\  

i = j = 3;\  

matrix = [random() for item in range(i\*j)]' '\  

random() in matrix'

\# Results:

\# i = j = 10000; 10 loops, best of 3: 1.61 sec per loop

\# i = j = 1000; 100 loops, best of 3: 15.9 msec per loop

\# i = j = 100; 10000 loops, best of 3: 158 usec per loop

\# i = j = 10; 1000000 loops, best of 3: 1.63 usec per loop

\# i = j = 3; 10000000 loops, best of 3: 0.194 usec per loop</code>

</li>
Comments:

-   `in` list: O(n) (following the [Python wiki page on time
    complexity][])
-   total complexity: O(n)

The observed speed increase is about a factor of 100 for every factor of
100 increase to `n` — in other words, O(n).

</li>
<li>
With use of `in` operator and a list comprehension

python -m timeit -s '\  

from random import random;\  

i = j = 3;\  

matrix = [[random() for row in range(j)] for column in range(i)]' '\  

random() in [row for row in matrix]'

\# Results:

\# i = j = 10000; 1000 loops, best of 3: 516 usec per loop

\# i = j = 1000: 10000 loops, best of 3: 54.2 usec per loop

\# i = j = 100: 100000 loops, best of 3: 6.52 usec per loop

\# i = j = 10: 1000000 loops, best of 3: 1.2 usec per loop

\# i = j = 3: 1000000 loops, best of 3: 0.457 usec per loop</code>

</li>
Comments:

-   one-dimensional list comprehension for square matrix: O(sqrt(n))
-   `in` list: O(n)
-   total complexity: O(sqrt(n)) + O(n) ∈ O(n)

Yet the observed speed increases by about a factor of 10 for every
factor of 100 increase to `n`. That looks like O(sqrt(n)), rather than
O(n). All I can think is that `in` must be implicitly optimized for use
with list comprehensions. But a search of documentation turns up nothing
to that effect. (I haven't yet looked at the source code.)

</li>
</ol>

<hr />
<p><strong>Correction (same day)</strong></p>
<p>Darius Bacon wrote: "Your test #2 looks wrong --
<code>random() in [row for row in matrix]</code> will check if <code>random()</code> is equal
to one of the rows in <code>matrix</code>, not if it's equal to an element in any
of the rows."</p>
<p>I checked it more carefully and he's right.</p>
<p>I rewrote it as</p>
<p>python -m timeit -s '\  </p>
<p>from random import random;\  </p>
<p>i = j = 3;\  </p>
<p>matrix = [[random() for row in range(j)] for column in range(i)]' '\  </p>
<p>random() in [item for row in matrix for item in row]'</p>
<p># i = j = 10000; 10 loops, best of 3: 4.3 sec per loop</p>
<p># i = j = 1000; 10 loops, best of 3: 44 msec per loop</p>
<p># i = j = 100; 1000 loops, best of 3: 393 usec per loop</p>
<p># i = j = 10; 100000 loops, best of 3: 5.83 usec per loop</p>
<p># i = j = 3; 1000000 loops, best of 3: 1.1 usec per loop</code></p>
<p>Now we see the 1:1 proportion between a factor of about 100 for change
in speed corresponding to a factor of 100 for change in <code>n</code>, just as the
order-of-growth equations predict.</p>
<p>And, as originally anticipated, using a linear array is, after all, much
faster than a list of lists.</p>
<p>[end]</p></div>
		<div>
			<h2>Comments</h2>
		<div>
	</div>	
		<footer>
		  <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme based on <a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a>.</p>
		  <p>&copy; David Prager Branner</p>
		</footer>
	  </div>

	</div>
</body>
</html>